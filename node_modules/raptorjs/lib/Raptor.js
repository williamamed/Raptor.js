var errorHandler = require('./middleware/errorHandler'),
	con=require('./Controller'),
	language = require('./middleware/language');

var helmet = require('helmet') 
 , express = require('express')
  , lodash = require('lodash')
// , routes = require('./routes')
// , user = require('./routes/user')
// , db = require('./models')
 , http = require('http')
 , passport = require('passport')
 , passportConfig = null 
 //, home = require('./routes/home')
 //, application = require('./routes/application')
, options= null 
, fs = require('fs')
, path = require('path')
, ViewFunctions = require('./ViewFunctions')
var aop=require('js_aop')
var fse=require('fs-extra')
var format= require('./../command/util/format')

module.exports={

	basePath:'./',

	errorHandler: errorHandler,
	Controller: con,
	language: language,

	bundleMap:{
		controllers:[],
		models:{},
		modelsConfig:{},
		middlewares:[]
	},
	bundles:{},
	/*
	* Lee la configuracion en options.js
	* y los modulos de src
	*/
	readConfig:function(){

		this.options=options;
		if(this.options.socketio && this.options.socketio.active)
			this.io=require('socket.io')
		else
			this.io=null;
		this.lookModules();
		this.prepareNodeComponents();
		//console.log(this.bundles)
	},

	readOptions:function(){
		options=require(path.join(this.basePath,'config/options'));
		this.options=options;
	},

	/**
	* Ejecuta el callback pasado por parametro en
	* en el scope quese le pasa como segundo argumento
	*/
	proxy: function(callback,scope){
		
		return function(req,res){
			var resp=callback.apply(scope,arguments);
			if(typeof resp == 'string')
				res.end(resp);
			
			if(typeof resp !== 'undefined')
				res.end();
		}
	},

	viewFunctions:{},
	/*
	* Entrada principal del framework
	*/
	main:function(basepath){
		this.basePath=basepath;

		passportConfig = require(path.join(this.basePath,'config/passport'));
		this.readOptions();

		var me=this;
		this.viewFunctions=new ViewFunctions(this);

		express.response.renderView=express.response.render;
		express.response.render=function(a,b,c){
			if(b){
				b.R=me.viewFunctions;
			}else{
				b={
					R:me.viewFunctions
				}
			}
			
			var div=a.split(':');
			if(div.length==2 && me.bundles[div[0]]){

				var view=path.join(me.basePath,'src',me.bundles[div[0]].path,'Views',div[1]);
				this.renderView(view,b,c);
				
			}else{
				this.renderView(a,b,c);
			}
			
		}

		this.app = express();

		this.readConfig();

		this.app.use('/public', express.static(basepath+'/public'));

		this.app.set('views', basepath+'/public')
		this.app.set('view engine','ejs')

		this.app.set('port', process.env.PORT || this.options.port || 3003)
		this.app.use(express.urlencoded())
		this.app.use(express.bodyParser())
		this.app.use(express.cookieParser())
		this.app.use(express.session({ 
			secret: this.options.secret,
			cookie: {httpOnly: true}//, secure: true }
		}))

		this.app.use(passport.initialize())
		this.app.use(passport.session())
		this.app.use(express.csrf())
		this.app.use(helmet())
		//this.app.use(helmet.csp())
		//this.app.use(helmet.xframe('sameorigin'))
		// Uncomment when using SSL
		//this.app.use(helmet.hsts())
		//this.app.use(helmet.iexss())
		//this.app.use(helmet.cacheControl())
		this.app.use(function(req, res, next){
			res.setHeader("Pragma", "no-cache");
			res.setHeader("Expires", "0");
			res.locals.csrftoken = req.csrfToken();
			next();
		})
		this.app.use(this.app.router)
		//express.errorHandler.title='Raptor'
		
		if(this.options.mode)
			this.app.set('env',this.options.mode)

		if ('development' === this.app.get('env')) {
			this.app.use(this.errorHandler())
		}

		//Leer los modulos y configuracion

		this.app.use(function(req, res, next) {
		  var err = new Error('404 Not Found');
		  err.status = 404;
		  next(err);
		});

		// error handler
		// no stacktraces leaked to user unless in development environment
		this.app.use(function(err, req, res, next) {
		  res.status(err.status || 500);
		  
		  res.render(path.join(__dirname,"/views/404.ejs"), { msg: err.message })
		});

		if(this.hasDatabaseConfig()){
			var obj={};
			obj=lodash.extend(obj,this.options.database.options)
			this.prepareDatabase(this.options.database.name,this.options.database.user,this.options.database.password,obj)
			
			this.database.sequelize
				  .authenticate()
					  .then(function(err) {
					  	console.log('Connection with database has been established successfully.');
					    me.startServer();
					  })
					  .catch(function (err) {
					    console.log('Unable to connect to the database:', err);
					    me.startServer();
					  });
		}else{
			this.startServer();
		}
		
		


	},
	/*
	* devuelve la direccion relativa a la raiz
	* del proyecto
	*/
	getLocation:function(name){
			return path.join(this.basePath,'src',name);
	},

	database:{},
   /*
	* Prepara la coneccion con la base de datos y lee los
	* modelos de los modulos de src. Esto todavia no manda
	* a conectar con la base de datos, solo prepara la coneccion
	*/
	prepareDatabase:function(database, user, pass, options){

		var Sequelize = require('sequelize')
		 , sequelize = new Sequelize(database,user,pass,options)
		 , me=this
		 if(this.app)
		 	this.app.set('sequelize', sequelize);
		 var associationBuffer=[];

		 for (var bundle in this.bundles) {
		 	var modelPath=path.join(this.basePath,'src',this.bundles[bundle].path,'Models');

		 	fs
			  .readdirSync(modelPath)
			  .filter(function(file) {
				return (file.indexOf('.') !== 0) && (file !== 'index.js')
			   })
			   .forEach(function(file) {
			   	var configModel=require(path.join(modelPath, file));

			   	if(typeof configModel=='object'){

				   	var model=sequelize.define(configModel.name,configModel.fields,configModel.methods,configModel.options);

				   	if(configModel.hooks){
				   		for (var hook in configModel.hooks) {
				   			model.hook(hook,configModel.hooks[hook]);
				   		}
				   	}

				   	if(configModel.associations)
				   		associationBuffer.push({
				   			callback:configModel.associations,
				   			model: model
				   		})
				   	 me.bundles[bundle].modelsConfig[model.name] = configModel
					 me.bundles[bundle].models[model.name] = model
				}

				if(typeof configModel=='function'){
					var model=require(path.join(modelPath, file));
					//me.app.configure(model);
					 var model = sequelize.import(path.join(modelPath, file))
					 me.bundles[bundle].models[model.name] = model
				}



			   })

		}
		for (var i = 0; i < associationBuffer.length; i++) {
			associationBuffer[i].callback.call(this,associationBuffer[i].model,this)
		};
		 //Leer los modelos de los modulos
		// Setup relationships
		  const models = sequelize.models;
		//  console.log( Object.keys(models))
		 Object.keys(sequelize.models).forEach(function(modelName) {
		    if ("associate" in sequelize.models[modelName]) {
		      sequelize.models[modelName].associate(sequelize.models,me);
		    }
		  });
	
		this.database=lodash.extend({
			sequelize: sequelize, 
			Sequelize: Sequelize
		}, this.database)

		return true;
	},
	hasDatabaseConfig:function(){
		if(this.options.database && this.options.database.name && this.options.database.user && this.options.database.password){
			if(this.options.database.state){
				if(this.options.database.state=='on')
					return true;
				else
					return false;
			}else{
				return true;
			}
		}
	},
	/*
	* Raptor.js - Node framework
	* 
	* Arranca el servidor web en el puerto
	* definido en la configuracion
	*/
	startServer:function(){
		var me=this;
		var server=http.createServer(this.app);
		var socketinfo='';
		if(this.io){
			this.io(server);
		    socketinfo=', \x1b[33;1msocket.io\x1b[22;39m is listening too';
		}
		
		server.listen(this.app.get('port'), function(){

			console.log('Raptor.js is listening on port ' + me.app.get('port')+socketinfo)

		});
	},
	/*
	* Raptor.js - Node framework
	* 
	* Busca los componentes definidos en
	* src
	*/
	lookModules:function(){
		var rutaSrc=this.basePath+'/src';
		var me=this;
		fs
		  .readdirSync(rutaSrc)
		  .forEach(function(file) {
		   	 
			   	 fs
			  		.readdirSync(path.join(rutaSrc,file))
			  		.filter(function(fileNode) {
			  			var sub=fileNode.substring(fileNode.length-4);
			  			
						return (fileNode.indexOf('.') !== 0) && (fileNode !== 'index.js') && (sub=='Node')
					   })
				  		.forEach(function(comp) {
				  			if(fs.existsSync(path.join(rutaSrc,file,comp))){

				  				var index= require(path.join(rutaSrc,file,comp));
				  				if(typeof index == 'function'){
				  					if(!me.bundles[comp]){
					  					me.bundles[comp]={
							   	 			name:comp,
							   	 			path: path.join(file,comp),
							   	 			vendor: file,
							   	 			main: index,
							   	 			controllers:[],
											models:{},
											modelsConfig:{},
											middlewares:[]
						   	 			}
						   	 			
				  					}else{
				  						console.error('The RaptorNode component ['+comp+'] cannot be defined, another component exists with the same name')
				  					}
				  				}
					   	 	}
					   	 	
						})
		   	 
			})
		 
	},

	/*
	* Raptor.js - Node framework
	* 
	* Lee los componentes para inicializarlos
	* @Param options prepara cada componente segun las opciones
	*/
	prepareNodeComponents:function(){
		var directives=lodash.extend(this.defaultPrepareComponentsOptions,this.options.prepareComponents)
		for (var bundle in this.bundles) {
			var main=new this.bundles[bundle].main()
			if(main.configure){
				main.configure(this)
			}
		}
		for (var bundle in this.bundles) {
			
			for (var directive in directives) {
				
				if( typeof directives[directive] == 'function'){

					directives[directive].call(this,this,this.bundles[bundle])
				}
			}
		}
		//console.info(this.bundles)
	},
	/*
	* Raptor.js - Node framework
	* 
	* Preparacion por defecto de los conceptos
	* del los modulos
	*/
	defaultPrepareComponentsOptions:{
		/*
		* Raptor.js - Node framework
		* 
		* @param Raptor R Instancia de la aplicacion Raptor
		* @param object bundle Componente leido
		*
		*/
		controllers:function(R,bundle){

			var rutaSrc=R.basePath+'/src';
			var pathController=path.join(rutaSrc,bundle.path,'Controllers');
			
			var controllerInstance=new R.Controller(R);
			var mainInstance=new bundle.main();
			var prefix=(mainInstance.prefix)?mainInstance.prefix:'';

			if(fs.existsSync(pathController)){

				fs
				  .readdirSync(pathController)
				  .filter(function(file) {
					return (file.indexOf('.') !== 0) && (file !== 'index.js')
				   })
				  .forEach(function(file) {

				  	var controller=require(path.join(pathController,file))

				  	if(typeof controller == 'object'){
				  		var commonJSPrefix='';
				  		if(controller['prefix'] && typeof controller['prefix'] == 'string')
				  			commonJSPrefix=controller['prefix'];

				  		for(var i in controller){

							if(typeof i == 'string'){
								if(i !== 'prefix'){
									if(typeof controller[i] == 'function'){
										R.app.all( commonJSPrefix + prefix + i , R.proxy( R.mainNodeBundle(mainInstance,R,bundle) , controllerInstance), R.proxy(controller[i],controllerInstance))
									}

									if(typeof controller[i] == 'object'){
										if(controller[i]['method']){
											controllerInstance.route(controller[i]['method'],  commonJSPrefix + i + prefix , R.mainNodeBundle(mainInstance,R,bundle) , controller[i].action)
										}else{
											controllerInstance.route('all', commonJSPrefix + i + prefix , R.mainNodeBundle(mainInstance,R,bundle) , controller[i].action)
										}
									}
								}
							}
							
						}

						bundle.controllers.push(controller);
				  	}

				  	if(typeof controller == 'function'){
				  		var claseES6=new controller(R,prefix,mainInstance, R.mainNodeBundle(mainInstance,R,bundle) );
				  		if(claseES6.configure){

				  			bundle.controllers.push(controller);
				  			claseES6.configure();
				  		}
				  	}

				  })

			}
			
		},
		/*
		* Raptor.js - Node framework
		* 
		* @param Raptor R Instancia de la aplicacion Raptor
		* @param object bundle Componente leido
		*
		*/
		models:function(R,bundle){

		},
		resources:function(R,bundle){
			/**
			var rutaSrc=R.basePath+'/src';
			var pathResources=path.join(rutaSrc,bundle.path,'Resources');

			if(fs.existsSync(pathResources)){
				var mod={
					name:'',
					time: (new Date).getTime()
				}

				fs.watch(pathResources,{recursive:true}, function (event, filename) {

					if(filename!==mod.name){
				 		mod.time=(new Date).getTime();
				 		mod.name=filename;
				 		
				 		R.copyResources(event,filename,pathResources,bundle,R)
				 	}else{
					 	if((new Date).getTime()-mod.time>=500){
					 		mod.time=(new Date).getTime();
					 		mod.name=filename;
					 		R.copyResources(event,filename,pathResources,bundle,R)
					 	}else
					 		mod.time=(new Date).getTime();
					}	

				 	return;
				});
			}*/
		}

	},


	copyResources:function(pathResources, bundle, R){
		if(R.app.get('env')==='development'){
			try {
				if(fs.existsSync(R.basePath+'/public/rmodules/'+bundle.vendor+'/'+bundle.name))
		 			fse.removeSync(R.basePath+'/public/rmodules/'+bundle.vendor+'/'+bundle.name);
		 		if(fs.existsSync(pathResources))
					fse.copySync(pathResources, R.basePath+'/public/rmodules/'+bundle.vendor+'/'+bundle.name)
				//console.log(format.get('Los recursos del módulo '+bundle.name+' fueron publicados en public/rmodules.',format.BLUE))
			}catch (err) {
				console.log(format.get(err,format.RED))
				return false;
			}
		}
	 	
	},

	mainNodeBundle:function(mainClass,R,bundle){
		return function(request,response,next){
			if(mainClass.entrance){
				mainClass.entrance(R)
			}
			R.copyResources(path.join(R.basePath,'src',bundle.path,'Resources'),bundle,R)
			//console.log('copy files')
			next();
		}
	},
	/*
	* Raptor.js - Node framework
	* 
	* @param string bundle Nombre del componente del cual se obtendran los modelos
	*
	*/
	getModels:function(bundle){
		if(this.bundles[bundle])
			return this.bundles[bundle].models;
		else
			return false;
	},
	/**
	* Raptor.js - Node framework
	* 
	* @param string name Nombre del componente del cual se obtendra la clase principal
	*
	*/
	requireNode:function(name){
		
		if(this.bundles[name] && fs.existsSync(path.join(this.basePath,'src',this.bundles[name].path))){
			return require(path.join(this.basePath,'src',this.bundles[name].path));
		}else
			return null;
	}
}