var errorHandler = require('./middleware/errorHandler'),
	con=require('./Controller'),
	extjs = require('./middleware/Extjs'),
	backbone = require('./middleware/Backbone'),
	language = require('./middleware/language'),
	client = require('./Client'),
	i18n = require('./util/i18n')

var helmet = require('helmet') 
 , express = require('express')
  , lodash = require('lodash')

 , http = require('http')
 , passport = require('passport')
 , passportConfig = null 

, options= null 
, fs = require('fs')
, path = require('path')
, ViewFunctions = require('./ViewFunctions')
var aop=require('js_aop')
var fse=require('fs-extra')
var format= require('./../command/util/format')
	//FileSessionStore=require('./FileSessionStore')
var FileStore = require('session-file-store')(express.session);

var __i18nDefinition={};

module.exports={

	basePath:'./',
	status:0,
	RUNNING:1,
	STOPPED:0,
	errorHandler: errorHandler,
	Controller: con,
	i18nClass: i18n,
	extjs: extjs,
	bundleMap:{
		controllers:[],
		models:{},
		modelsConfig:{},
		middlewares:[]
	},
	bundles:{},
	Promise: require('sequelize').Promise,
	hooks:{
		middleware:function(point){
			if(point=='before'){
				if(!this._beforeMiddleware)
					this._beforeMiddleware=Promise.defer()
				return this._beforeMiddleware;
			}
			if(point=='after'){
				if(!this._afterMiddleware)
					this._afterMiddleware=Promise.defer()
				return this._afterMiddleware;
			}
		},
		config:function(point){
			if(point=='before'){
				if(!this._beforeConfig)
					this._beforeConfig=Promise.defer()
				return this._beforeConfig;
			}
			if(point=='after'){
				if(!this._afterConfig)
					this._afterConfig=Promise.defer()
				return this._afterConfig;
			}
		}
	},
	/*
	* Lee la configuracion en options.js
	* y los modulos de src
	*/
	readConfig:function(){

		this.options=options;
		
		if(this.options.socketio && this.options.socketio.active)
			this._io=require('socket.io')
		else
			this._io=null;
		this.lookModules();
		//this.prepareNodeComponents();
		//console.log(this.bundles)
	},

	readOptions:function(){
		options=require(path.join(this.basePath,'config/options.json'));
		this.options=options;
	},

	/**
	* Ejecuta el callback pasado por parametro en
	* en el scope quese le pasa como segundo argumento
	*/
	proxy: function(callback,scope){
		
		return function(req,res){
			var resp=callback.apply(scope,arguments);
			if(typeof resp == 'string')
				res.end(resp);
			
			if(typeof resp !== 'undefined')
				res.end();
		}
	},

	/**
	* Puntos calientes de insercionde contenido
	*
	*/
	viewHotSpot:{},

	/**
	* Establece un contenido para un nombre de HotSpot
	* @param string name Nombre del HotSpot
	* @param string content Contenido a inyectar en el HotSpot
	*/
	setViewPlugin:function(name,content){
		if(this.viewHotSpot[name]){
			this.viewHotSpot[name].push(content);
		}else{
			this.viewHotSpot[name]=new Array(content);
		}
	},

	getViewPlugin:function(name){
		if(this.viewHotSpot[name]){
			return this.viewHotSpot[name];
		}else{
			return [];
		}
	},

	cleanViewPlugin:function(name){
		if(this.viewHotSpot[name])
			this.viewHotSpot[name]=[];
	},
	cleanAllViewPlugin:function(){
		this.viewHotSpot=[];
	},
	/*
	* Entrada principal del framework
	*/
	main:function(basepath){
		//Eventos
		var events = require('events');
		this.__proto__ = events.EventEmitter.prototype;
		events.EventEmitter.call(this);

		this.basePath=basepath;
		
		//passportConfig = require(path.join(this.basePath,'config/passport'));
		this.readOptions();


		var me=this;
		
		this.viewFunctions=new ViewFunctions(this);

		//Introspeccion del metodo send
		express.response.__send=express.response.send;
		express.response.send=function(body){
			me.emit('sendresponse',this.req)
			var content=client.getContent(body,me,this);
			this.__send(content)
		}

		//Introspeccion del metodo render
		express.response.__render=express.response.render;
		express.response.render=function(a,b,c){
			b=lodash.extend( (b)?b:{} ,{ R: me.viewFunctions });
			me.viewFunctions.__setRequest(this.req);
			var div=a.split(':');
			if(div.length==2 && me.bundles[div[0]]){

				var view=path.join(me.basePath,'src',me.bundles[div[0]].path,'Views',div[1]);
				this.__render(view,b,c);
				
			}else{
				this.__render(a,b,c);
			}
			
		}


		express.request.flash=function(name,message){
			if(!this.session.flash)
				this.session.flash={};
			if(!message){
				var msg=this.session.flash[name];
				delete this.session.flash[name];
				return msg;
			}else{
				this.session.flash[name]=message;
			}
			
		}

		this.app = express();
		
		// Serialize Sessions
		passport.serializeUser(function(user, done){
			done(null, user);
		});

		//Deserialize Sessions
		passport.deserializeUser(function(user, done){
			done(null, user);
		});

		
		this.app.use('/public', express.static(basepath+'/public'));
		this.readConfig();
		this.app.set('views', basepath+'/public')
		this.app.set('view engine','ejs')

		this.app.set('port', process.env.PORT || this.options.port || 3003)
		this.app.use(express.urlencoded())
		this.app.use(express.bodyParser())
		
		this.app.use(express.cookieParser())
		this.app.use(express.session({ 
			secret: this.options.secret,
			store: new FileStore({
			  path: this.basePath+"/cache/session/",  //directory where session files will be stored
			  useAsync: true,
			  reapInterval: 5000,
			  maxAge: 10000
			}),
			resave: true,
			saveUninitialized: false,
			cookie: {httpOnly: true}//, secure: true }

		}))
		
		this.app.use(passport.initialize())
		this.app.use(passport.session())
		this.app.use(express.csrf({ 
			cookie:true,
			key: this.options.cookieName?this.options.cookieName+'0':'_csrf_def'
		}))
		this.app.use(function(req, res, next){
			 res.cookie((me.options.cookieName)?me.options.cookieName+'A':'_csrf_red', req.csrfToken());
			 next();
		})
		this.app.use(helmet())
		//this.app.use(helmet.csp())
		//this.app.use(helmet.xframe('sameorigin'))
		// Uncomment when using SSL
		//this.app.use(helmet.hsts())
		//this.app.use(helmet.iexss())
		//this.app.use(helmet.cacheControl())
		this.app.use(function(req, res, next){
			res.setHeader("Pragma", "no-cache");
			res.setHeader("Expires", "0");
			res.locals.csrftoken = req.csrfToken();
			next();
		})
		this.app.use(this.requestViewPlugin())
		this.app.use(this.mapOption())
		this.app.use(language.prepare(this, (this.options.language)?this.options.language:{} ))
		
		this.app.use(function (err, req, res, next) {
		  if (err.code !== 'EBADCSRFTOKEN') return next(err)

		  // handle CSRF token errors here
		  res.status(403)
		  res.end('Forbiden request by Raptor')
		})
		//var accessLogStream = fs.createWriteStream(this.basePath + '/access.log', {flags: 'a'})
		//this.app.use(express.logger({immediate:true}))

		this.stackedComponents();
		
		
		this.app.use(this.app.router)
		//express.errorHandler.title='Raptor'
		
		if(this.options.mode)
			this.app.set('env',this.options.mode)
		/**
		* Validar el modo produccion para poner un mensaje personalizado
		* 
		*/
		if ('development' === this.app.get('env')) {
			this.app.use(this.errorHandler())
		}

		//Leer los modulos y configuracion
		this.prepareNodeComponents();
		this.i18n=i18n(__i18nDefinition)

		this.app.use(function(req, res, next) {
		  var err = new Error('404 Not Found');
		  err.status = 404;
		  next(err);
		});

		// error handler
		// no stacktraces leaked to user unless in development environment
		this.app.use(function(err, req, res, next) {
		  res.status(err.status || 500);
		  
		  res.render(path.join(__dirname,"/views/404.ejs"), { msg: err.message })
		});

		if(this.hasDatabaseConfig()){
			var obj={
				logging:function(){}
			};
			obj=lodash.extend(obj,this.options.database.options)
			this.prepareDatabase(this.options.database.name,this.options.database.user,this.options.database.password,obj)
			
			this.database.sequelize
				  .authenticate()
					  .then(function(err) {
					  	console.log('Connection with database has been established successfully.');
					    me.startServer();
					  })
					  .catch(function (err) {
					    console.log('Unable to connect to the database:', err);
					    me.startServer();
					  });
		}else{
			this.startServer();
		}
		
		


	},
	/*
	* devuelve la direccion relativa a la raiz
	* del proyecto
	*/
	getLocation:function(name){
			return path.join(this.basePath,'src',name);
	},

	database:{},
   /*
	* Prepara la coneccion con la base de datos y lee los
	* modelos de los modulos de src. Esto todavia no manda
	* a conectar con la base de datos, solo prepara la coneccion
	*/
	prepareDatabase:function(database, user, pass, options){

		var Sequelize = require('sequelize')
		 , sequelize = new Sequelize(database,user,pass,options)
		 , me=this
		 if(this.app)
		 	this.app.set('sequelize', sequelize);
		 var associationBuffer=[];

		 for (var bundle in this.bundles) {
		 	var modelPath=path.join(this.basePath,'src',this.bundles[bundle].path,'Models');

		 	fs
			  .readdirSync(modelPath)
			  .filter(function(file) {
				return (file.indexOf('.') !== 0) && (file !== 'index.js')
			   })
			   .forEach(function(file) {
			   	var configModel=require(path.join(modelPath, file));

			   	if(typeof configModel=='object'){

				   	var model=sequelize.define(configModel.name,configModel.fields,configModel.methods,configModel.options);

				   	if(configModel.hooks){
				   		for (var hook in configModel.hooks) {
				   			model.hook(hook,configModel.hooks[hook]);
				   		}
				   	}

				   	if(configModel.associations)
				   		associationBuffer.push({
				   			callback:configModel.associations,
				   			model: model
				   		})
				   	 me.bundles[bundle].modelsConfig[model.name] = configModel
				   	 if(fs.existsSync(path.join(modelPath,'..','Repositories', file))){
				   	 	var repo=require(path.join(modelPath,'..','Repositories', file))
				   	 	repo.R=me
				   	 	model=lodash.extend(model,repo)
				   	 	
				   	 }
				   	
					 me.bundles[bundle].models[model.name] = model
				}

				if(typeof configModel=='function'){
					var model=require(path.join(modelPath, file));
					//me.app.configure(model);
					 var model = sequelize.import(path.join(modelPath, file))
					 if(fs.existsSync(path.join(modelPath,'..','Repositories', file))){
				   	 	var repo=require(path.join(modelPath,'..','Repositories', file))
				   	 	repo.R=me
				   	 	model=lodash.extend(model,repo)
				   	 	
				   	 }
					 me.bundles[bundle].models[model.name] = model
				}



			   })

		}
		for (var i = 0; i < associationBuffer.length; i++) {
			associationBuffer[i].callback.call(this,associationBuffer[i].model,this)
		};
		 //Leer los modelos de los modulos
		// Setup relationships
		  const models = sequelize.models;
		//  console.log( Object.keys(models))
		 Object.keys(sequelize.models).forEach(function(modelName) {
		    if ("associate" in sequelize.models[modelName]) {
		      sequelize.models[modelName].associate(sequelize.models,me);
		    }
		    if ("initRepo" in sequelize.models[modelName]) {
		      sequelize.models[modelName].initRepo(sequelize.models,me);
		    }
		  });
	
		this.database=lodash.extend({
			sequelize: sequelize, 
			Sequelize: Sequelize
		}, this.database)

		return true;
	},
	hasDatabaseConfig:function(){
		if(this.options.database && this.options.database.name && this.options.database.user){
			if(this.options.database.state){
				if(this.options.database.state=='on')
					return true;
				else
					return false;
			}else{
				return true;
			}
		}
	},
	/*
	* Raptor.js - Node framework
	* 
	* Arranca el servidor web en el puerto
	* definido en la configuracion
	*/
	startServer:function(){
		var me=this;
		var server=http.createServer(this.app);
		var socketinfo='';
		if(this._io){
			this.io=this._io(server);
		    socketinfo=', \x1b[33;1msocket.io\x1b[22;39m is listening too';
		}
		
		server.listen(this.app.get('port'), function(){
			me.status=me.RUNNING;
			console.log('Raptor.js is listening on port ' + me.app.get('port')+socketinfo)
			me.emit('serverrunning')

		});
	},
	/*
	* Raptor.js - Node framework
	* 
	* Busca los componentes definidos en
	* src
	*/
	lookModules:function(){
		var rutaSrc=this.basePath+'/src';
		var me=this;
		me.hooks.config('after').resolve(me)
		fs
		  .readdirSync(rutaSrc)
		  .forEach(function(file) {
		   	 
			   	 fs
			  		.readdirSync(path.join(rutaSrc,file))
			  		.filter(function(fileNode) {
			  			var sub=fileNode.substring(fileNode.length-4);
			  			
						return (fileNode.indexOf('.') !== 0) && (fileNode !== 'index.js') && (sub=='Node')
					   })
				  		.forEach(function(comp) {
				  			if(fs.existsSync(path.join(rutaSrc,file,comp))){

				  				var index= require(path.join(rutaSrc,file,comp));
				  				if(typeof index == 'function'){
				  					if(!me.bundles[comp]){
					  					me.bundles[comp]={
							   	 			name:comp,
							   	 			path: path.join(file,comp),
							   	 			vendor: file,
							   	 			main: index,
							   	 			controllers:[],
											models:{},
											modelsConfig:{},
											middlewares:[],
											hooks:{
												middleware: function(point){
													if(point=='before'){
														if(!this._beforeMiddleware)
															this._beforeMiddleware=Promise.defer()
														return this._beforeMiddleware;
													}
													if(point=='after'){
														if(!this._afterMiddleware)
															this._afterMiddleware=Promise.defer()
														return this._afterMiddleware;
													}
												},
												config: function(point){
													if(point=='before'){
														if(!this._beforeConfig)
															this._beforeConfig=Promise.defer()
														return this._beforeConfig;
													}
													if(point=='after'){
														if(!this._beforeConfig)
															this._beforeConfig=Promise.defer()
														return this._beforeConfig;
													}
												}
											}
						   	 			}
						   	 			var main=new index()
										if(main.configure && me.on){
											me.bundles[comp].hooks.config('before').resolve(me)
											main.configure(me)
											me.bundles[comp].hooks.config('after').resolve(me)
										}
				  					}else{
				  						console.error('The RaptorNode component ['+comp+'] cannot be defined, another component exists with the same name')
				  					}
				  				}
					   	 	}
					   	 	
						})
		   	 
			})
		 	me.hooks.config('after').resolve(me)
	},

	/*
	* Raptor.js - Node framework
	* 
	* Lee los componentes para inicializarlos
	* @Param options prepara cada componente segun las opciones
	*/
	prepareNodeComponents:function(){
		var directives=lodash.extend(this.defaultPrepareComponentsOptions,this.options.prepareComponents)
		
		for (var bundle in this.bundles) {

			for (var directive in directives) {
				
				if( typeof directives[directive] == 'function'){

					directives[directive].call(this,this,this.bundles[bundle])
				}
			}
		}
		//console.info(this.bundles)
	},

	stackedComponents:function(){
		var me=this;
		this.hooks.middleware('before').resolve(this)
		for (var bundle in me.bundles) {
			var main=new me.bundles[bundle].main()
			if(main.middleware){
				me.bundles[bundle].hooks.middleware('before').resolve(me)
				main.middleware(me)
			}
			me.bundles[bundle].hooks.middleware('after').resolve(me)
		}
		
		this.hooks.middleware('after').resolve(this)
		
	},
	/*
	* Raptor.js - Node framework
	* 
	* Preparacion por defecto de los conceptos
	* del los modulos
	*/
	defaultPrepareComponentsOptions:{
		/*
		* Raptor.js - Node framework
		* 
		* @param Raptor R Instancia de la aplicacion Raptor
		* @param object bundle Componente leido
		*
		*/
		controllers:function(R,bundle){

			var rutaSrc=R.basePath+'/src';
			var pathController=path.join(rutaSrc,bundle.path,'Controllers');
			
			
			var mainInstance=new bundle.main();
			var prefix=(mainInstance.prefix)?mainInstance.prefix:'';

			if(fs.existsSync(pathController)){

				fs
				  .readdirSync(pathController)
				  .filter(function(file) {
					return (file.indexOf('.') !== 0) && (file !== 'index.js')
				   })
				  .forEach(function(file) {

				  	var controller=require(path.join(pathController,file))
				  	
				  	 
				  	if(typeof controller == 'object'){

				  		var commonJSPrefix='';
				  		if(controller['prefix'] && typeof controller['prefix'] == 'string')
				  			commonJSPrefix=controller['prefix'];

				  		var controllerInstance=new R.Controller(R, prefix + commonJSPrefix ,mainInstance,R.mainNodeBundle(mainInstance,R,bundle));

				  		for(var i in controller){

							if(typeof i == 'string'){
								if(i !== 'prefix'){
									if(typeof controller[i] == 'function'){
										controllerInstance.route('all', i  , controller[i])
										//R.app.all( prefix + commonJSPrefix  + i , R.proxy( R.mainNodeBundle(mainInstance,R,bundle) , controllerInstance), R.proxy(controller[i],controllerInstance))
									}

									if(typeof controller[i] == 'object'){
										if(controller[i]['method']){
											controllerInstance.route(controller[i]['method'],  i  ,  controller[i].action)
										}else{
											controllerInstance.route('all', i  , controller[i].action)
										}
									}
								}
							}
							
						}

						bundle.controllers.push(controller);
				  	}

				  	if(typeof controller == 'function'){
				  		var claseES6=new controller(R,prefix,mainInstance, R.mainNodeBundle(mainInstance,R,bundle) );
				  		if(claseES6.configure){

				  			bundle.controllers.push(controller);
				  			claseES6.configure();
				  		}
				  	}

				  })

			}
			
		},
		/*
		* Raptor.js - Node framework
		* 
		* @param Raptor R Instancia de la aplicacion Raptor
		* @param object bundle Componente leido
		*
		*/
		models:function(R,bundle){

		},
		i18n:function(R,bundle){
			var i18nLocation=path.join(R.basePath,'src',bundle.path,'i18n','language.json');
			if(fs.existsSync(i18nLocation)){
				var def=require(i18nLocation);
				__i18nDefinition[bundle.name]=def;
			}
		},
		compressor:function(R,bundle){
			var compressor=path.join(R.basePath,'src',bundle.path,'Compressor','Compress.js');
			if(fs.existsSync(compressor)){
				bundle.compressor=require(compressor);
			}
		},
		resources:function(R,bundle){
			/**
			var rutaSrc=R.basePath+'/src';
			var pathResources=path.join(rutaSrc,bundle.path,'Resources');

			if(fs.existsSync(pathResources)){
				var mod={
					name:'',
					time: (new Date).getTime()
				}

				fs.watch(pathResources,{recursive:true}, function (event, filename) {

					if(filename!==mod.name){
				 		mod.time=(new Date).getTime();
				 		mod.name=filename;
				 		
				 		R.copyResources(event,filename,pathResources,bundle,R)
				 	}else{
					 	if((new Date).getTime()-mod.time>=500){
					 		mod.time=(new Date).getTime();
					 		mod.name=filename;
					 		R.copyResources(event,filename,pathResources,bundle,R)
					 	}else
					 		mod.time=(new Date).getTime();
					}	

				 	return;
				});
			}*/
		}

	},

	/*
	* Raptor.js - Node framework
	* Rutina de copia de los recursos del componente especificado
	*
	* @author William Amed
	*
	*/
	copyResources:function(bundle, callback, preCompile){
		if(typeof bundle=='string'){
			if(this.bundles[bundle])
				bundle=this.bundles[bundle];
			else
				return;
		}
		
		if(this.app.get('env')==='development'){
			var pathResources=path.join(this.basePath,'src',bundle.path,'Resources');
			var R=this;
			if(typeof callback=='boolean'){
				preCompile=callback;
				callback=function(){}
			}
			if(!callback){
				preCompile=false;
				callback=function(){}
			}
			try {
				if(fs.existsSync(this.basePath+'/public/rmodules/'+bundle.vendor+'/'+bundle.name)){
		 			fse.removeSync(this.basePath+'/public/rmodules/'+bundle.vendor+'/'+bundle.name);
		 			if(fs.existsSync(pathResources)){
							fse.copySync(pathResources, R.basePath+'/public/rmodules/'+bundle.vendor+'/'+bundle.name);
							if(preCompile){
								extjs.preCompileApp(path.join(R.basePath,'public/rmodules',bundle.vendor,bundle.name));
								backbone.preCompileApp(path.join(R.basePath,'public/rmodules',bundle.vendor,bundle.name));
							}

							callback()
						}
		 		}
		 		else
			 		if(fs.existsSync(pathResources)){
						fse.copySync(pathResources, this.basePath+'/public/rmodules/'+bundle.vendor+'/'+bundle.name);
						if(preCompile){
							extjs.preCompileApp(path.join(this.basePath,'public/rmodules',bundle.vendor,bundle.name));
							backbone.preCompileApp(path.join(this.basePath,'public/rmodules',bundle.vendor,bundle.name));
						}
						callback()
					}
				//console.log(format.get('Los recursos del módulo '+bundle.name+' fueron publicados en public/rmodules.',format.BLUE))
			}catch (err) {
				console.log(format.get(err,format.RED))
				return false;
			}
		}
	 	
	},
	/*
	* Raptor.js - Node framework
	* Ejecuta la rutina de entrada al componente, copia los recursos del
	* componente a ejecutar
	*
	* @author William Amed
	* @param {function} mainClass Clase principal del bundle
	* @param {object} R Referencia a la clase core de Raptor
	* @param {object} bundle Configuracion del bundle
	*
	*/
	mainNodeBundle:function(mainClass,R,bundle){
		return function(request,response,next){
			request.language.initBundle(bundle);
			
			if(!response.req.xhr && response.req.method=='GET' && (!response.get('Content-type') || response.get('Content-type').indexOf('text/html')!=-1)){
				R.copyResources(bundle,true)
			}
			if(mainClass.entrance){
				mainClass.entrance(R)
			}
			
			next();
		}
	},
	
	
	/*
	* Raptor.js - Node framework
	*
	* Devuelve los modelos del componente especificado o false si el componente
	* no existe
	*
	* @author William Amed
	* @param {string} bundle Nombre del componente del cual se obtendran los modelos
	* @return {object|false} Modelos del componente especificado
	*/
	getModels:function(bundle){
		if(this.bundles[bundle])
			return this.bundles[bundle].models;
		else
			return false;
	},
	/**
	* Raptor.js - Node framework
	*
	* Devuelve la clase principal del componente especificado
	*
	* @author William Amed
	* @param {string} name Nombre del componente del cual se obtendra la clase principal
	* @return {function|null} Clase principal del componente especificado
	*
	*/
	requireNode:function(name){
		
		if(this.bundles[name] && fs.existsSync(path.join(this.basePath,'src',this.bundles[name].path))){
			return require(path.join(this.basePath,'src',this.bundles[name].path));
		}else
			return null;
	},
	/**
	* Raptor.js - Node framework
	* Mapea un valor del body del request con una propiedad del objeto especificado
	*  Ej.
	*  house={
	*     owner:{
	*		 name: 'initial name'
	*     }
	*  }
	*  req.mapOption('fullname','owner.name',house)
	*
	* @author William Amed
	* @param {string} name Nombre del valor que viene en el body del request
	* @param {string} propiedad Nombre y posicion de la propiedad a mapear en el objeto ej.'objeto.otrapropiedad.name'
	* @param {object} Objeto que sera mapeado
	* @return {function} Middleware para mapear valores del request contra un objeto
	*/
	mapOption:function(){
		var self=this;
		return function(req,res,next){
			req.mapOption=function(field,option,original,format){

				if(field){
					var splited=option.split('.');
					var value=req.body[field];
					if(typeof format=='function')
						var value=format(value)
					original=self.recursiveOption(splited,value,0,original)

					return original;
					
				}

			}
			next()
		}
	},

	requestViewPlugin:function(){
		return function(req,res,next){
			req.viewPlugin={
				__plugins:{},
				set:function(name,value){
					if(this.__plugins[name])
						this.__plugins[name].push(value)
					else
						this.__plugins[name]=[value]
				},
				get:function(name){
					if(this.__plugins[name])
						return this.__plugins[name];
					else
						return [];
				},
				remove:function(name){
					if(this.__plugins[name])
						this.__plugins[name]=[];
				},
				removeAll:function(){
					this.__plugins=[];
				}
			}
			next()
		}
	},
	/**
	* Raptor.js - Node framework
	* Funcion utilitaria
	*
	* @author William Amed
	* 
	*/
	recursiveOption:function(list,value,pos,object){
		if(list.length-1>pos){
			object[list[pos]]=this.recursiveOption(list,value,pos+1,object[list[pos]]);
			return object;
		}else{
			object[list[pos]]=value;
			return object;
		}

	},

	waitUntil:function(cond){
		while(cond){}
	},
	
	getSecurityManager:function(name){
		if(!this._securityManager){
			this._securityManager=require('./SecurityManager');
			this._securityManager.R=this;
		}
		if(!this._securityManagerNames){
			this._securityManagerNames={}
		}
		if(name){
			if(!this._securityManagerNames[name]){
				this._securityManagerNames[name]=new this._securityManager(this)
			}
			return this._securityManagerNames[name];
		}else
			return new this._securityManager(this);
	},
	aop:{
		before:function(obj,method,advice){
			var before=obj[method];
			var orig=[];
			orig.push(function(){
				return before.apply(obj,arguments)
			})
			obj[method]=function(){
				return advice.apply(obj,orig.concat(arguments))
			}
		}
	},
	stackUtil:function(_stack,callback,scope){
		var pos=0;
		var self=this;
		var stack=_stack?_stack:[];
		return {

			begin:function(){
				this.nextPos(pos);
			},
			nextPos:function(position){
				if(position<stack.length){
					if(scope)
						self=scope
					if(typeof callback=="function")
						callback.apply(self,[stack[position]]);
					this.nextPos(position+1)
				}
				
			}
		}
	},
	/**
	*
	*
	*
	*/
	migration:function(name,action){
		var me=this;
		this.on('serverrunning',function(){
			if(!action)
				action='create'
			if(!me.database.sequelize)
				return;
			if(me.bundles[name] && fs.existsSync(path.join(me.basePath,'src',me.bundles[name].path)) && fs.existsSync(path.join(me.basePath,'src',me.bundles[name].path)+"/Migration/skeleton.js")){
			
				var done=function(msg){
					if(msg)
						console.log(msg)
					else
						console.log("Migration done!!")
				}
				var save=function(makeData){
					fs.writeFileSync(path.join(me.basePath,'src',me.bundles[name].path)+"/Migration/data.json",JSON.stringify(makeData))
				}
				console.log("Running migration for bundle "+name)
				var migration=require(path.join(me.basePath,'src',me.bundles[name].path)+"/Migration/skeleton")
				var queryInterface=me.database.sequelize.queryInterface;
				var data={};
				if(fs.existsSync(path.join(me.basePath,'src',me.bundles[name].path)+"/Migration/data.json"))
					data=require(path.join(me.basePath,'src',me.bundles[name].path)+"/Migration/data.json");

				migration.createTableFromModel=function(model){
					return queryInterface.createTable(model.tableName,model.attributes)
				}
				var routing=function(tableNames) {
					me.migrationTables={}
					for (var i = 0; i < tableNames.length; i++) {
						me.migrationTables[tableNames[i]]=true
					};
					migration.tables=me.migrationTables
					migration.watch=migration.watch?migration.watch:[];
					var flagExist=0;
					
					for (var i = 0; i < migration.watch.length; i++) {
						if(migration.tables[migration.watch[i]])
							flagExist++
						
					};
					if(action=='create')
						if(flagExist==0)
							migration[action](queryInterface,me,data,done)
						else
							done('No migration needed')
					if(action=='export')
						if(flagExist==migration.watch.length && !fs.existsSync(path.join(me.basePath,'src',me.bundles[name].path)+"/Migration/data.json"))
							migration[action](queryInterface,me,done,save)
						else
							done('No migration export needed(Delete the data.json file to force a new migration data file)')
					if(action=='destroy')
						migration[action](queryInterface,me,data,done)
					
				}

				if(!me.migrationTables)
					queryInterface.showAllTables().then(routing)
				else{
					routing(Object.keys(me.migrationTables))
				}
				
				
			}else{
				console.error('No migration file for bundle '+name)
			}
		})
	}
}